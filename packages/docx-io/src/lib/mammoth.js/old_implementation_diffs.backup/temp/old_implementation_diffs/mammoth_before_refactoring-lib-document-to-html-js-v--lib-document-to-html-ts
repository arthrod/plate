--- mammoth_before_refactoring/lib/document-to-html.js	2026-02-19 23:58:28
+++ ./lib/document-to-html.ts	2026-02-20 00:49:48
@@ -1,13 +1,11 @@
-var _ = require('underscore');
+var promises = require('./promises.ts');
+var documents = require('./documents.ts');
+var htmlPaths = require('./styles/html-paths.ts');
+var results = require('./results.ts');
+var images = require('./images.ts');
+var Html = require('./html/index.ts');
+var writers = require('./writers/index.ts');
 
-var promises = require('./promises');
-var documents = require('./documents');
-var htmlPaths = require('./styles/html-paths');
-var results = require('./results');
-var images = require('./images');
-var Html = require('./html');
-var writers = require('./writers');
-
 exports.DocumentConverter = DocumentConverter;
 
 // Token prefixes for tracked changes - parsed by import-toolbar-button.tsx
@@ -26,10 +24,12 @@
 function DocumentConverter(options) {
   return {
     convertToHtml(element) {
-      var comments = _.indexBy(
-        element.type === documents.types.document ? element.comments : [],
-        'commentId'
-      );
+      var comments = (
+        element.type === documents.types.document ? element.comments : []
+      ).reduce((indexedComments, comment) => {
+        indexedComments[comment.commentId] = comment;
+        return indexedComments;
+      }, {});
       var conversion = new DocumentConversion(options, comments);
       return conversion.convertToHtml(element);
     },
@@ -45,7 +45,7 @@
 
   var referencedComments = [];
 
-  options = _.extend({ ignoreEmptyParagraphs: true }, options);
+  options = Object.assign({ ignoreEmptyParagraphs: true }, options);
   var idPrefix = options.idPrefix === undefined ? '' : options.idPrefix;
   var ignoreEmptyParagraphs = options.ignoreEmptyParagraphs;
 
@@ -79,7 +79,7 @@
             }
             if (node.children) {
               return [
-                _.extend({}, node, {
+                Object.assign({}, node, {
                   children: replaceDeferred(node.children),
                 }),
               ];
@@ -212,7 +212,7 @@
     return (image, messages) =>
       promises
         .attempt(() => convertImage(image, messages))
-        .caught((error) => {
+        .catch((error) => {
           messages.push(results.error(error));
           return [];
         });
@@ -249,8 +249,7 @@
   }
 
   function convertTableChildren(element, messages, options) {
-    var bodyIndex = _.findIndex(
-      element.children,
+    var bodyIndex = element.children.findIndex(
       (child) => child.type !== documents.types.tableRow || !child.isHeader
     );
     if (bodyIndex === -1) {
@@ -261,18 +260,18 @@
       children = convertElements(
         element.children,
         messages,
-        _.extend({}, options, { isTableHeader: false })
+        Object.assign({}, options, { isTableHeader: false })
       );
     } else {
       var headRows = convertElements(
         element.children.slice(0, bodyIndex),
         messages,
-        _.extend({}, options, { isTableHeader: true })
+        Object.assign({}, options, { isTableHeader: true })
       );
       var bodyRows = convertElements(
         element.children.slice(bodyIndex),
         messages,
-        _.extend({}, options, { isTableHeader: false })
+        Object.assign({}, options, { isTableHeader: false })
       );
       children = [
         Html.freshElement('thead', {}, headRows),
@@ -333,7 +332,12 @@
       payload.text = extractTextFromElements(comment.body);
       try {
         var richContent = convertElements(comment.body, messages, options);
-        payload.body = Html.simplify(richContent);
+        var writer = writers.writer({
+          prettyPrint: options.prettyPrint,
+          outputFormat: options.outputFormat,
+        });
+        Html.write(writer, Html.simplify(richContent));
+        payload.body = writer.asString();
       } catch (e) {
         var detail = '';
         if (e && typeof e.message === 'string') {
@@ -623,7 +627,7 @@
 }
 
 function flatMap(values, func) {
-  return _.flatten(values.map(func), true);
+  return values.flatMap(func);
 }
 
 function walkHtml(nodes, callback) {
